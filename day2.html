<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 2 - Stack the Presents | 10 Days Till Christmas</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Cinzel+Decorative:wght@700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Playfair Display', Georgia, serif;
            background: linear-gradient(135deg, #1a3a4a 0%, #0d2030 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #fff;
            overflow: hidden;
        }

        .header {
            text-align: center;
            padding: 10px;
            width: 100%;
            background: rgba(0,0,0,0.3);
        }

        .header h1 {
            font-family: 'Great Vibes', cursive;
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 3px;
        }

        .header p {
            color: #a8d4ff;
            font-size: 0.9rem;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffd700;
            text-decoration: none;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.2s;
            z-index: 10;
        }

        .back-link:hover {
            transform: translateX(-5px);
        }

        .game-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        #gameCanvas {
            border: 4px solid #ffd700;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.3);
            cursor: pointer;
        }

        .score-display {
            font-family: 'Cinzel Decorative', serif;
            font-size: 1.3rem;
            color: #ffd700;
            margin-top: 8px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .instructions {
            margin-top: 5px;
            text-align: center;
            color: #a8d4ff;
            font-size: 0.85rem;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .overlay.hidden {
            display: none;
        }

        .overlay h2 {
            font-family: 'Great Vibes', cursive;
            font-size: 3rem;
            color: #ffd700;
            margin-bottom: 20px;
        }

        .overlay p {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .overlay .final-score {
            font-family: 'Cinzel Decorative', serif;
            font-size: 2rem;
            color: #ff6b6b;
            margin: 20px 0;
        }

        .play-btn {
            background: linear-gradient(145deg, #c41e3a, #8b0000);
            border: 3px solid #ffd700;
            color: #ffd700;
            font-family: 'Cinzel Decorative', serif;
            font-size: 1.3rem;
            padding: 15px 40px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .play-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }

        .high-score {
            color: #a8d4ff;
            margin-top: 15px;
        }

        .mobile-message {
            display: none;
            min-height: 100vh;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 40px;
        }

        .mobile-message img {
            width: 120px;
            margin-bottom: 20px;
        }

        .mobile-message h2 {
            font-family: 'Great Vibes', cursive;
            font-size: 2rem;
            color: #f5d742;
            margin-bottom: 15px;
        }

        .mobile-message p {
            color: #fff;
            font-size: 1.1rem;
        }

        @media (max-width: 1024px) {
            .header, .game-wrapper, .back-link {
                display: none !important;
            }
            .mobile-message {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div class="mobile-message">
        <img src="icons/614133-winter/svg/015-present.svg" alt="Present">
        <h2>Santa's workshop doesn't fit on small screens!</h2>
        <p>Please visit on a computer to play.</p>
    </div>

    <a href="index.html" class="back-link">
        <span>←</span> Back to Calendar
    </a>

    <div class="header">
        <h1>Day 2: Stack the Presents</h1>
        <p>December 16th</p>
    </div>

    <div class="game-wrapper">
        <canvas id="gameCanvas" width="700" height="700"></canvas>
        <div class="score-display">Presents: <span id="currentScore">0</span></div>
        <div class="instructions">Click or press Space to drop the present!</div>
    </div>

    <div class="overlay" id="startOverlay">
        <h2>Stack the Presents!</h2>
        <img src="icons/614133-winter/svg/015-present.svg" alt="Present" style="width: 100px; margin: 20px;">
        <p>Stack presents as high as you can!</p>
        <p style="font-size: 0.9rem; color: #a8d4ff;">Drop each present perfectly to keep the stack growing</p>
        <button class="play-btn" id="startBtn">Start Stacking!</button>
    </div>

    <div class="overlay hidden" id="gameOverOverlay">
        <h2>Tower Tumbled!</h2>
        <div class="final-score">Presents: <span id="finalScore">0</span></div>
        <p class="high-score">Best: <span id="highScore">0</span></p>
        <button class="play-btn" id="restartBtn">Try Again</button>
    </div>

    <!-- Win Overlay -->
    <div class="overlay hidden" id="winOverlay">
        <h2>You Win!</h2>
        <img src="icons/614133-winter/svg/015-present.svg" alt="Present" style="width: 100px; margin: 20px;">
        <p style="font-size: 1.3rem; max-width: 400px; line-height: 1.6; margin: 20px;">You're the greatest gift I've ever received, I can't wait to see as our relationship continues to build! ❤️</p>
        <a href="index.html" class="play-btn" style="text-decoration: none;">Back to Calendar</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = false;
        let score = 0;
        let highScore = localStorage.getItem('stackPresentsHighScore') || 0;
        document.getElementById('highScore').textContent = highScore;

        // Present colors - festive combinations
        const presentColors = [
            { box: '#e74c3c', ribbon: '#ffd700', pattern: '#c0392b' },  // Red + Gold
            { box: '#27ae60', ribbon: '#e74c3c', pattern: '#1e8449' },  // Green + Red
            { box: '#3498db', ribbon: '#f1c40f', pattern: '#2980b9' },  // Blue + Yellow
            { box: '#9b59b6', ribbon: '#1abc9c', pattern: '#8e44ad' },  // Purple + Teal
            { box: '#e67e22', ribbon: '#ecf0f1', pattern: '#d35400' },  // Orange + White
            { box: '#1abc9c', ribbon: '#e74c3c', pattern: '#16a085' },  // Teal + Red
        ];

        // Stack of placed presents
        let stack = [];

        // Current moving present
        let currentPresent = null;

        // Base platform
        const baseY = canvas.height - 60;
        const baseWidth = 150;
        const presentHeight = 40;
        const startingPresentWidth = 150; // Same as base

        // Camera offset for scrolling effect
        let cameraY = 0;
        let targetCameraY = 0;

        // Falling pieces (when overhang is cut)
        let fallingPieces = [];

        // Particles for perfect drops
        let particles = [];

        // Snowflakes
        let snowflakes = [];
        for (let i = 0; i < 60; i++) {
            snowflakes.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 3 + 1,
                speed: Math.random() * 1 + 0.5,
                wobble: Math.random() * Math.PI * 2
            });
        }

        // Get random present color
        function getRandomColor() {
            return presentColors[Math.floor(Math.random() * presentColors.length)];
        }

        // Initialize first present
        function createNewPresent() {
            const topStack = stack[stack.length - 1];
            const width = topStack ? topStack.width : startingPresentWidth;
            const y = topStack ? topStack.y - presentHeight : baseY - presentHeight;

            currentPresent = {
                x: 0,
                y: y,
                width: width,
                height: presentHeight,
                speed: 1.5 + Math.min(score * 0.1, 3), // Speed increases with score
                direction: 1,
                color: getRandomColor()
            };
        }

        // Draw background gradient
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a1628');
            gradient.addColorStop(0.5, '#1a3a5c');
            gradient.addColorStop(1, '#2d5a7b');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Draw snowflakes
        function drawSnowflakes() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            snowflakes.forEach(flake => {
                ctx.beginPath();
                ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
                ctx.fill();

                // Update position
                flake.y += flake.speed;
                flake.x += Math.sin(flake.wobble) * 0.5;
                flake.wobble += 0.02;

                // Reset if off screen
                if (flake.y > canvas.height) {
                    flake.y = -5;
                    flake.x = Math.random() * canvas.width;
                }
            });
        }

        // Draw a present box
        function drawPresent(x, y, width, height, color, applyCamera = true) {
            const drawY = applyCamera ? y + cameraY : y;

            // Don't draw if off screen
            if (drawY > canvas.height + 50 || drawY + height < -50) return;

            ctx.save();

            // Main box with gradient
            const boxGradient = ctx.createLinearGradient(x, drawY, x + width, drawY + height);
            boxGradient.addColorStop(0, color.box);
            boxGradient.addColorStop(1, color.pattern);
            ctx.fillStyle = boxGradient;
            ctx.fillRect(x, drawY, width, height);

            // Box border/shadow
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, drawY, width, height);

            // Horizontal ribbon
            ctx.fillStyle = color.ribbon;
            const ribbonHeight = height * 0.25;
            ctx.fillRect(x, drawY + (height - ribbonHeight) / 2, width, ribbonHeight);

            // Vertical ribbon
            const ribbonWidth = width * 0.15;
            ctx.fillRect(x + (width - ribbonWidth) / 2, drawY, ribbonWidth, height);

            // Bow on top (only if wide enough)
            if (width > 40) {
                const bowCenterX = x + width / 2;
                const bowY = drawY + height * 0.3;
                const bowSize = Math.min(width * 0.2, 20);

                ctx.fillStyle = color.ribbon;

                // Left loop
                ctx.beginPath();
                ctx.ellipse(bowCenterX - bowSize * 0.8, bowY, bowSize, bowSize * 0.6, -0.3, 0, Math.PI * 2);
                ctx.fill();

                // Right loop
                ctx.beginPath();
                ctx.ellipse(bowCenterX + bowSize * 0.8, bowY, bowSize, bowSize * 0.6, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Center knot
                ctx.beginPath();
                ctx.arc(bowCenterX, bowY, bowSize * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(x + 3, drawY + 3, width * 0.3, height - 6);

            ctx.restore();
        }

        // Draw the base/ground
        function drawBase() {
            const groundY = baseY + cameraY;

            // Snow ground
            ctx.fillStyle = '#e8f4f8';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY + 100);

            // Snow bumps
            ctx.fillStyle = '#fff';
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.ellipse(i + 20, groundY, 25, 12, 0, Math.PI, 0);
                ctx.fill();
            }

            // Base platform (sleigh/table)
            const platformX = (canvas.width - baseWidth) / 2;
            const platformWidth = baseWidth;

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(platformX, groundY - 15, platformWidth, 20);

            // Platform top highlight
            ctx.fillStyle = '#A0522D';
            ctx.fillRect(platformX, groundY - 15, platformWidth, 5);

            // Platform legs
            ctx.fillStyle = '#654321';
            ctx.fillRect(platformX + 10, groundY + 5, 15, 30);
            ctx.fillRect(platformX + platformWidth - 25, groundY + 5, 15, 30);
        }

        // Draw falling pieces
        function updateAndDrawFallingPieces() {
            fallingPieces = fallingPieces.filter(piece => {
                piece.y += piece.velocityY;
                piece.velocityY += 0.5; // gravity
                piece.x += piece.velocityX;
                piece.rotation += piece.rotationSpeed;

                const drawY = piece.y + cameraY;

                if (drawY < canvas.height + 100) {
                    ctx.save();
                    ctx.translate(piece.x + piece.width / 2, drawY + piece.height / 2);
                    ctx.rotate(piece.rotation);
                    ctx.globalAlpha = Math.max(0, 1 - (drawY - canvas.height) / 100);

                    // Draw simplified falling piece
                    ctx.fillStyle = piece.color.box;
                    ctx.fillRect(-piece.width / 2, -piece.height / 2, piece.width, piece.height);
                    ctx.fillStyle = piece.color.ribbon;
                    ctx.fillRect(-piece.width / 2, -2, piece.width, 4);

                    ctx.restore();
                    return true;
                }
                return false;
            });
        }

        // Particles for perfect stacks
        function createParticles(x, y, width) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x + Math.random() * width,
                    y: y,
                    velocityX: (Math.random() - 0.5) * 6,
                    velocityY: -Math.random() * 4 - 2,
                    size: Math.random() * 4 + 2,
                    color: Math.random() > 0.5 ? '#ffd700' : '#fff',
                    life: 1
                });
            }
        }

        function updateAndDrawParticles() {
            particles = particles.filter(p => {
                p.x += p.velocityX;
                p.y += p.velocityY;
                p.velocityY += 0.15;
                p.life -= 0.02;

                if (p.life > 0) {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y + cameraY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    return true;
                }
                return false;
            });
        }

        // Drop the current present
        function dropPresent() {
            if (!gameRunning || !currentPresent) return;

            const topStack = stack[stack.length - 1];
            let landingX, landingWidth;

            if (topStack) {
                // Calculate overlap
                const overlapLeft = Math.max(currentPresent.x, topStack.x);
                const overlapRight = Math.min(currentPresent.x + currentPresent.width, topStack.x + topStack.width);
                const overlapWidth = overlapRight - overlapLeft;

                if (overlapWidth <= 0) {
                    // Completely missed!
                    gameOver();
                    return;
                }

                // Check if it's a perfect drop (within 5px tolerance)
                const isPerfect = Math.abs(currentPresent.x - topStack.x) < 5 &&
                                  currentPresent.width === topStack.width;

                if (isPerfect) {
                    // Perfect drop - keep full width
                    landingX = topStack.x;
                    landingWidth = topStack.width;
                    createParticles(landingX, currentPresent.y, landingWidth);
                } else {
                    // Create falling piece for overhang
                    if (currentPresent.x < topStack.x) {
                        // Overhang on left
                        const cutWidth = topStack.x - currentPresent.x;
                        fallingPieces.push({
                            x: currentPresent.x,
                            y: currentPresent.y,
                            width: cutWidth,
                            height: presentHeight,
                            color: currentPresent.color,
                            velocityX: -2,
                            velocityY: 0,
                            rotation: 0,
                            rotationSpeed: -0.1
                        });
                    }
                    if (currentPresent.x + currentPresent.width > topStack.x + topStack.width) {
                        // Overhang on right
                        const cutX = topStack.x + topStack.width;
                        const cutWidth = (currentPresent.x + currentPresent.width) - cutX;
                        fallingPieces.push({
                            x: cutX,
                            y: currentPresent.y,
                            width: cutWidth,
                            height: presentHeight,
                            color: currentPresent.color,
                            velocityX: 2,
                            velocityY: 0,
                            rotation: 0,
                            rotationSpeed: 0.1
                        });
                    }

                    landingX = overlapLeft;
                    landingWidth = overlapWidth;
                }
            } else {
                // First present - land on base
                const baseX = (canvas.width - baseWidth) / 2;
                const overlapLeft = Math.max(currentPresent.x, baseX);
                const overlapRight = Math.min(currentPresent.x + currentPresent.width, baseX + baseWidth);
                const overlapWidth = overlapRight - overlapLeft;

                if (overlapWidth <= 0) {
                    gameOver();
                    return;
                }

                // Check for overhang on first block too
                if (currentPresent.x < baseX) {
                    const cutWidth = baseX - currentPresent.x;
                    fallingPieces.push({
                        x: currentPresent.x,
                        y: currentPresent.y,
                        width: cutWidth,
                        height: presentHeight,
                        color: currentPresent.color,
                        velocityX: -2,
                        velocityY: 0,
                        rotation: 0,
                        rotationSpeed: -0.1
                    });
                }
                if (currentPresent.x + currentPresent.width > baseX + baseWidth) {
                    const cutX = baseX + baseWidth;
                    const cutWidth = (currentPresent.x + currentPresent.width) - cutX;
                    fallingPieces.push({
                        x: cutX,
                        y: currentPresent.y,
                        width: cutWidth,
                        height: presentHeight,
                        color: currentPresent.color,
                        velocityX: 2,
                        velocityY: 0,
                        rotation: 0,
                        rotationSpeed: 0.1
                    });
                }

                landingX = overlapLeft;
                landingWidth = overlapWidth;
            }

            // Check if block is too small
            if (landingWidth < 10) {
                gameOver();
                return;
            }

            // Add to stack
            stack.push({
                x: landingX,
                y: currentPresent.y,
                width: landingWidth,
                height: presentHeight,
                color: currentPresent.color
            });

            score++;
            document.getElementById('currentScore').textContent = score;

            // Check for win at 20 presents
            if (score >= 20) {
                checkWin();
                return;
            }

            // Update camera target
            if (stack.length > 8) {
                targetCameraY = (stack.length - 8) * presentHeight;
            }

            // Create next present
            createNewPresent();
        }

        // Check for win
        function checkWin() {
            gameRunning = false;
            document.getElementById('winOverlay').classList.remove('hidden');
        }

        // Game over
        function gameOver() {
            gameRunning = false;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('stackPresentsHighScore', highScore);
            }

            // Create falling present
            if (currentPresent) {
                fallingPieces.push({
                    x: currentPresent.x,
                    y: currentPresent.y,
                    width: currentPresent.width,
                    height: presentHeight,
                    color: currentPresent.color,
                    velocityX: currentPresent.direction * 2,
                    velocityY: 0,
                    rotation: 0,
                    rotationSpeed: currentPresent.direction * 0.15
                });
            }

            setTimeout(() => {
                document.getElementById('finalScore').textContent = score;
                document.getElementById('highScore').textContent = highScore;
                document.getElementById('gameOverOverlay').classList.remove('hidden');
            }, 800);
        }

        // Start/restart game
        function startGame() {
            gameRunning = true;
            score = 0;
            stack = [];
            fallingPieces = [];
            particles = [];
            cameraY = 0;
            targetCameraY = 0;
            currentPresent = null;

            document.getElementById('currentScore').textContent = score;
            document.getElementById('startOverlay').classList.add('hidden');
            document.getElementById('gameOverOverlay').classList.add('hidden');
            document.getElementById('winOverlay').classList.add('hidden');

            createNewPresent();
            gameLoop();
        }

        // Main game loop
        function gameLoop() {
            // Clear and draw background
            drawBackground();
            drawSnowflakes();

            // Smooth camera movement
            cameraY += (targetCameraY - cameraY) * 0.1;

            // Draw base/ground
            drawBase();

            // Draw stacked presents
            stack.forEach(present => {
                drawPresent(present.x, present.y, present.width, present.height, present.color);
            });

            // Update and draw falling pieces
            updateAndDrawFallingPieces();

            // Update and draw particles
            updateAndDrawParticles();

            // Update and draw current present
            if (currentPresent && gameRunning) {
                currentPresent.x += currentPresent.speed * currentPresent.direction;

                // Bounce off walls
                if (currentPresent.x + currentPresent.width > canvas.width) {
                    currentPresent.direction = -1;
                    currentPresent.x = canvas.width - currentPresent.width;
                } else if (currentPresent.x < 0) {
                    currentPresent.direction = 1;
                    currentPresent.x = 0;
                }

                drawPresent(currentPresent.x, currentPresent.y, currentPresent.width, currentPresent.height, currentPresent.color);
            }

            // Draw score on canvas
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 36px "Cinzel Decorative", serif';
            ctx.textAlign = 'center';
            ctx.fillText(score, canvas.width / 2, 50);

            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            } else {
                // Keep animating falling pieces even after game over
                if (fallingPieces.length > 0) {
                    requestAnimationFrame(gameLoop);
                }
            }
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);

        canvas.addEventListener('click', dropPresent);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameRunning && document.getElementById('startOverlay').classList.contains('hidden') === false) {
                    startGame();
                } else if (!gameRunning && document.getElementById('gameOverOverlay').classList.contains('hidden') === false) {
                    startGame();
                } else {
                    dropPresent();
                }
            }
        });

        // Initial draw
        drawBackground();
        drawSnowflakes();
        drawBase();
    </script>
</body>
</html>
